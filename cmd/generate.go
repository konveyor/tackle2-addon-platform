package main

import (
	"errors"
	"net/url"
	"os"
	"path"
	fp "path/filepath"
	"strconv"
	"strings"

	"github.com/konveyor/tackle2-addon/repository"
	"github.com/konveyor/tackle2-hub/api"
	"github.com/konveyor/tackle2-hub/binding"
	"github.com/konveyor/tackle2-hub/nas"
	yaml "sigs.k8s.io/yaml/goyaml.v3"
)

type Files = map[string]string
type Map = map[string]any

// Generate assets action.
type Generate struct {
	BaseAction
}

// Run executes that action.
// - fetch the application asset repository.
// - for each associated generator:
//   - fetch template repository.
//   - build values file.
//   - generate assets.
//   - write files into asset repository.
//
// - commit asset repository.
func (a *Generate) Run(d *Data) (err error) {
	err = a.setApplication()
	if err != nil {
		return
	}
	addon.Activity(
		"[Generate] Fetch manifest for application (id=%d): %s",
		a.application.ID,
		a.application.Name)
	if a.application.Assets == nil {
		err = wrap(
			&RepositoryNotDefined{
				Role: "Assets",
			})
		return
	}
	identity, err := a.selectIdentity("asset")
	if err != nil {
		return
	}
	assetRepo, err := repository.New(
		AssetDir,
		a.application.Assets,
		identity)
	if err != nil {
		return
	}
	err = assetRepo.Fetch()
	if err != nil {
		return
	}
	assetDir := path.Join(
		AssetDir,
		a.application.Assets.Path)
	err = nas.MkDir(assetDir, 0755)
	if err != nil {
		return
	}
	err = a.purge(assetDir)
	if err != nil {
		return
	}
	generators, err := a.generators(d.Profiles)
	if err != nil {
		return
	}
	for _, gen := range generators {
		addon.Activity(
			"[Generate] Using generator (id=%d): %s.",
			gen.ID,
			gen.Name)
		var templateDir string
		templateDir, err = a.cloneTemplates(gen)
		if err != nil {
			return
		}
		if d.Render {
			err = a.render(
				gen,
				d.Params,
				templateDir,
				assetDir)
		} else {
			assetDir := a.genAssetDir(assetDir, gen)
			err = nas.MkDir(assetDir, 0755)
			if err != nil {
				return
			}
			err = a.generate(
				gen,
				d.Params,
				templateDir,
				assetDir)
		}
		if err != nil {
			return
		}
	}
	msg := "Generated by konveyor.\n"
	msg += "Task: id="
	msg += os.Getenv("TASK")
	msg += "\n"
	err = assetRepo.Commit([]string{assetDir}, msg)
	if err != nil {
		return
	}
	return
}

// assetDir returns a unique asset directory path for the generator.
func (a *Generate) genAssetDir(rootDir string, gen *api.Generator) (assetDir string) {
	genId := gen.Name
	if genId == "" {
		genId = strconv.Itoa(int(gen.ID))
	}
	templateDir := path.Base(gen.Repository.Path)
	if templateDir == "" {
		parsedURL, err := url.Parse(gen.Repository.URL)
		if err != nil {
			parsedURL = &url.URL{}
		}
		templateDir = path.Base(parsedURL.Path)
		if templateDir == "" {
			templateDir = parsedURL.Hostname()
		}
	}
	assetDir = path.Join(
		rootDir,
		genId,
		templateDir)
	return
}

// purge assetDir.
func (a *Generate) purge(assetDir string) (err error) {
	err = fp.Walk(
		assetDir,
		func(entPath string, ent os.FileInfo, nErr error) (err error) {
			if nErr != nil {
				if !os.IsNotExist(nErr) {
					err = wrap(nErr)
				}
				return
			}
			if entPath == assetDir {
				return
			}
			if strings.HasPrefix(path.Base(entPath), ".") {
				if ent.IsDir() {
					err = fp.SkipDir
				}
				return
			}
			if ent.IsDir() {
				err = nas.RmDir(entPath)
				if err != nil {
					err = wrap(err)
					return
				}
			} else {
				err = os.Remove(entPath)
				if err != nil {
					err = wrap(err)
					return
				}
				addon.Activity("[gen] Deleted: %s", entPath)
			}
			return
		})
	if err != nil {
		err = wrap(err)
		return
	}
	return
}

// generate writes values and template files.
func (a *Generate) generate(gen *api.Generator, params api.Map, templateDir string, assetDir string) (err error) {
	values, err := a.values(gen, params)
	if err != nil {
		return
	}
	err = a.writeValues(assetDir, values)
	if err != nil {
		err = wrap(err)
		return
	}

	err = a.writeTemplates(templateDir, assetDir)
	if err != nil {
		err = wrap(err)
		return
	}
	return
}

// render the templates using engine.
func (a *Generate) render(gen *api.Generator, params api.Map, templateDir string, assetDir string) (err error) {
	values, err := a.values(gen, params)
	if err != nil {
		return
	}
	engine, err := a.selectEngine(gen.Kind)
	if err != nil {
		return
	}
	files, err := engine.Render(templateDir, values)
	if err != nil {
		return
	}
	for assetPath, content := range files {
		assetPath = fp.Join(assetDir, path.Base(assetPath))
		err = a.writeAsset(assetPath, content)
		if err != nil {
			err = wrap(err)
			return
		}
	}
	return
}

// writeAsset writes a generated asset file.
func (a *Generate) writeAsset(assetPath, content string) (err error) {
	err = os.WriteFile(assetPath, []byte(content), 0666)
	if err != nil {
		err = wrap(err)
		return
	}
	addon.Activity("[Generate] Created: %s", assetPath)
	return
}

// writeValues writes value.yaml to the assetDir.
func (a *Generate) writeValues(assetDir string, values api.Map) (err error) {
	assetDir = path.Dir(assetDir)
	b, err := yaml.Marshal(values)
	if err != nil {
		err = wrap(err)
		return
	}
	assetPath := fp.Join(assetDir, "values.yaml")
	err = a.writeAsset(assetPath, string(b))
	if err != nil {
		err = wrap(err)
		return
	}
	return
}

// writeTemplates to the assetDir.
func (a *Generate) writeTemplates(templateDir, assetDir string) (err error) {
	err = fp.Walk(
		templateDir,
		func(entPath string, ent os.FileInfo, nErr error) (err error) {
			if nErr != nil {
				err = wrap(nErr)
				return
			}
			if strings.HasPrefix(path.Base(entPath), ".") {
				if ent.IsDir() {
					err = fp.SkipDir
				}
				return
			}
			assetPath, _ := fp.Rel(templateDir, entPath)
			assetPath = fp.Join(assetDir, assetPath)
			if ent.IsDir() {
				err = nas.MkDir(assetPath, 0777)
				if err != nil {
					err = wrap(err)
					return
				}
			} else {
				var b []byte
				b, err = os.ReadFile(entPath)
				if err != nil {
					err = wrap(err)
					return
				}
				err = a.writeAsset(assetPath, string(b))
				if err != nil {
					err = wrap(err)
					return
				}
			}
			return
		})
	if err != nil {
		err = wrap(err)
		return
	}
	return
}

// values returns the `values` file passed to the generator.
func (a *Generate) values(gen *api.Generator, params api.Map) (values api.Map, err error) {
	tags, err := a.tags()
	if err != nil {
		return
	}
	redacted, manifest, err := a.manifest()
	if err != nil {
		return
	}
	v := Values{}
	v.with(&a.application, redacted, tags)
	values = v.asMap()
	a.inject(values, gen.Values)
	a.inject(values, params)
	err = a.attachValues(gen, values)
	if err != nil {
		return
	}
	v.with(&a.application, manifest, tags)
	values = v.asMap()
	a.inject(values, gen.Values)
	a.inject(values, params)
	return
}

// attachValues attaches values file passed to the generator.
func (a *Generate) attachValues(gen *api.Generator, values api.Map) (err error) {
	genId := strconv.Itoa(int(gen.ID))
	name := genId + "-values.yaml-"
	tf, err := os.CreateTemp("", name)
	if err != nil {
		err = wrap(err)
		return
	}
	en := yaml.NewEncoder(tf)
	defer func() {
		_ = tf.Close()
		_ = os.Remove(tf.Name())
		_ = en.Close()
	}()
	_, _ = tf.WriteString("---\n")
	_, _ = tf.WriteString("# generator (id=")
	_, _ = tf.WriteString(genId)
	_, _ = tf.WriteString(") ")
	_, _ = tf.WriteString(gen.Name)
	_, _ = tf.WriteString("\n")
	err = en.Encode(values)
	if err != nil {
		err = wrap(err)
		return
	}
	_ = tf.Close()
	f, err := addon.File.Post(tf.Name())
	if err != nil {
		return
	}
	addon.Attach(f)
	return
}

// cloneCode gets code repository.
func (a *Generate) cloneCode() (sourceDir string, err error) {
	if a.application.Repository == nil {
		err = wrap(
			&RepositoryNotDefined{
				Role: "Source",
			})
		return
	}
	var options []any
	idapi := addon.Application.Identity(a.application.ID)
	identity, found, err := idapi.Find("source")
	if err != nil {
		return
	}
	if found {
		options = append(options, identity)
	}
	sourceDir = path.Join(
		SourceDir,
		strings.Split(
			path.Base(
				a.application.Repository.URL),
			".")[0])
	var rp repository.SCM
	rp, err = repository.New(
		sourceDir,
		a.application.Repository,
		options...)
	if err != nil {
		return
	}
	err = rp.Fetch()
	if err != nil {
		return
	}
	sourceDir = path.Join(
		sourceDir,
		a.application.Repository.Path)
	return
}

// cloneTemplates clones the repository associated with the generator.
func (a *Generate) cloneTemplates(gen *api.Generator) (templateDir string, err error) {
	genId := strconv.Itoa(int(gen.ID))
	templateDir = path.Join(
		TemplateDir,
		genId)
	err = os.MkdirAll(templateDir, 0755)
	if err != nil {
		err = wrap(err)
		return
	}
	template, err := repository.New(
		templateDir,
		gen.Repository,
		gen.Identity)
	if err != nil {
		return
	}
	err = template.Fetch()
	if err != nil {
		return
	}
	templateDir = path.Join(
		templateDir,
		gen.Repository.Path)
	return
}

// profiles returns requested profiles.
func (a *Generate) profiles(requested Profiles) (matched []*api.TargetProfile, err error) {
	for _, ref := range a.application.Archetypes {
		var arch *api.Archetype
		arch, err = addon.Archetype.Get(ref.ID)
		if err != nil {
			return
		}
		for _, p := range arch.Profiles {
			if requested.match(&p) {
				matched = append(matched, &p)
			}
		}
	}
	return
}

// generators returns requested generators.
func (a *Generate) generators(requested Profiles) (list []*api.Generator, err error) {
	profiles, err := a.profiles(requested)
	if err != nil {
		return
	}
	for _, p := range profiles {
		var gen *api.Generator
		for _, ref := range p.Generators {
			gen, err = addon.Generator.Get(ref.ID)
			if err == nil {
				list = append(list, gen)
			} else {
				return
			}
		}
	}
	return
}

// inject nodes into the document.
func (a *Generate) inject(document, inject api.Map) {
	report := make(api.Map)
	if document == nil {
		return
	}
	for k, value := range inject {
		part := strings.Split(k, ".")
		leaf := len(part) - 1
		node := Map(document)
		for i := range part {
			p := part[i]
			if i == leaf {
				report[p] = value
				node[p] = value
				break
			}
			v, found := node[p]
			nested, cast := v.(Map)
			if !found || !cast {
				nested = make(Map)
				node[p] = nested
			}
			report[p] = nested
			node = nested
		}
	}
	for k, v := range report {
		addon.Activity("[gen] Inject: %s = %#v", k, v)
	}
	return
}

// tags returns an array of tags.
// format: category=tag.
func (a *Generate) tags() (tags []string, err error) {
	catList, err := addon.TagCategory.List()
	if err != nil {
		return
	}
	catMap := make(map[uint]string)
	for _, cat := range catList {
		catMap[cat.ID] = cat.Name
	}
	for _, ref := range a.application.Tags {
		var tag *api.Tag
		tag, err = addon.Tag.Get(ref.ID)
		if err != nil {
			return
		}
		tags = append(
			tags,
			strings.Join(
				[]string{
					catMap[tag.Category.ID],
					tag.Name},
				"="))
	}
	return
}

// manifest returns the application manifest.
// fallback: A file named: manifest.yaml in the source repository.
func (a *Generate) manifest() (redacted, manifest *api.Manifest, err error) {
	mapi := addon.Application.Manifest(a.application.ID)
	redacted, err = mapi.Get()
	if err != nil {
		if errors.Is(err, &binding.NotFound{}) {
			redacted, err = a.userManifest()
			manifest = redacted
		}
		return
	}
	manifest, err = addon.Manifest.Get(
		redacted.ID,
		binding.Param{Key: api.Injected, Value: "1"},
		binding.Param{Key: api.Decrypted, Value: "1"})
	if err != nil {
		return
	}
	addon.Activity(
		"[Generate] Using manifest id=%d",
		manifest.ID)
	return
}

// userManifest returns the manifest contained in the repository.
func (a *Generate) userManifest() (manifest *api.Manifest, err error) {
	if a.application.Repository == nil {
		err = &ManifestNotFound{}
		return
	}
	sourceDir, err := a.cloneCode()
	if err != nil {
		return
	}
	file := path.Join(sourceDir, "manifest.yaml")
	f, err := os.Open(file)
	if err != nil {
		if os.IsNotExist(err) {
			err = &ManifestNotFound{}
		} else {
			err = wrap(err)
		}
		return
	}
	defer func() {
		_ = f.Close()
	}()
	manifest = &api.Manifest{}
	decoder := yaml.NewDecoder(f)
	err = decoder.Decode(&manifest.Content)
	if err == nil {
		addon.Activity(
			"[Generate] Using manifest at: ",
			file)
	}
	return
}

// Profiles selected profiles.
type Profiles []api.Ref

// match returns true when the profile ID matched.
func (f Profiles) match(p *api.TargetProfile) (matched bool) {
	if len(f) == 0 {
		matched = true
		return
	}
	for _, ref := range f {
		matched = ref.ID == p.ID
		if matched {
			break
		}
	}
	return
}

// Values used by templates.
type Values struct {
	Application struct {
		Name            string
		Owner           string
		Contributors    []string
		Archetypes      []string
		BusinessService string `yaml:"businessService"`
		Repository      *api.Repository
		Binary          string
	}
	Manifest api.Map
	Tags     []string
}

// with populates using the specified resources.
func (v *Values) with(a *api.Application, m *api.Manifest, tags []string) {
	app := &v.Application
	app.Name = a.Name
	if a.Owner != nil {
		app.Owner = a.Owner.Name
	}
	for _, ref := range a.Contributors {
		app.Contributors = append(
			app.Contributors,
			ref.Name)
	}
	for _, ref := range a.Archetypes {
		app.Archetypes = append(
			app.Archetypes,
			ref.Name)
	}
	if a.BusinessService != nil {
		app.BusinessService = a.BusinessService.Name
	}
	app.Repository = a.Repository
	app.Binary = a.Binary
	v.Manifest = m.Content
	v.Tags = tags
}

// asMap returns an api.Map representation.
func (v *Values) asMap() (m api.Map) {
	b, _ := yaml.Marshal(v)
	_ = yaml.Unmarshal(b, &m)
	return
}
