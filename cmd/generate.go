package main

import (
	"errors"
	"os"
	"path"
	"strconv"
	"strings"

	"github.com/konveyor/tackle2-addon/repository"
	"github.com/konveyor/tackle2-hub/api"
	"github.com/konveyor/tackle2-hub/binding"
	yaml "sigs.k8s.io/yaml/goyaml.v3"
)

type Files = map[string]string
type Map = map[string]any

// Generate assets action.
type Generate struct {
	BaseAction
}

// Run executes that action.
// - fetch the application asset repository.
// - for each associated generator:
//   - fetch template repository.
//   - build values file.
//   - generate assets.
//   - write files into asset repository.
//
// - commit asset repository.
func (a *Generate) Run(d *Data) (err error) {
	err = a.setApplication()
	if err != nil {
		return
	}
	addon.Activity(
		"[Gen] Fetch manifest for application (id=%d): %s",
		a.application.ID,
		a.application.Name)
	if a.application.Assets == nil {
		err = Wrap(
			&RepositoryNotDefined{
				Role: "Assets",
			})
		return
	}
	identity, err := a.selectIdentity("asset")
	if err != nil {
		return
	}
	assetRepo, err := repository.New(
		AssetDir,
		a.application.Assets,
		identity)
	if err != nil {
		return
	}
	err = assetRepo.Fetch()
	if err != nil {
		return
	}
	assetDir := path.Join(
		AssetDir,
		a.application.Assets.Path)
	generators, err := a.generators(d.Profiles)
	if err != nil {
		return
	}
	paths := []string{}
	for _, gen := range generators {
		addon.Activity(
			"[Gen] Using generator (id=%d): %s.",
			gen.ID,
			gen.Name)
		var templateDir string
		templateDir, err = a.fetchTemplates(gen)
		if err != nil {
			return
		}
		var names []string
		names, err = a.generate(
			gen,
			d.Params,
			templateDir,
			assetDir)
		if err != nil {
			return
		}
		paths = append(
			paths,
			names...)
	}
	msg := "Generated by konveyor.\n"
	msg += "Task: id="
	msg += os.Getenv("TASK")
	msg += "\n"
	err = assetRepo.Commit(paths, msg)
	if err != nil {
		return
	}
	return
}

// generate executes a generator.
func (a *Generate) generate(
	gen *api.Generator,
	params api.Map,
	templateDir string,
	assetDir string) (paths []string, err error) {
	//
	values, err := a.values(gen.Values, params)
	if err != nil {
		return
	}
	if err != nil {
		return
	}
	engine, err := a.selectEngine(gen.Kind)
	if err != nil {
		return
	}
	files, err := engine.Generate(templateDir, values)
	if err != nil {
		return
	}
	for name, content := range files {
		assetPath := path.Join(
			assetDir,
			path.Base(name))
		err = a.writeAsset(assetPath, content)
		if err == nil {
			paths = append(paths, assetPath)
		} else {
			return
		}
	}
	return
}

// writeAsset writes a generated asset file.
func (a *Generate) writeAsset(assetPath, content string) (err error) {
	f, err := os.Create(assetPath)
	if err != nil {
		err = Wrap(err)
		return
	}
	defer func() {
		_ = f.Close()
	}()
	_, err = f.Write([]byte(content))
	if err != nil {
		err = Wrap(err)
		return
	}
	addon.Activity(
		"[Gen] created: %s",
		f.Name())
	return
}

// values returns the `values` file passed to the generator.
func (a *Generate) values(injected ...api.Map) (values api.Map, err error) {
	tags, err := a.tags()
	if err != nil {
		return
	}
	manifest, err := a.manifest()
	if err != nil {
		return
	}
	for _, d := range injected {
		a.inject(manifest.Content, d)
	}
	application := api.Map{
		"name":            a.application.Name,
		"owner":           a.refName(a.application.Owner),
		"contributors":    a.refNames(a.application.Contributors),
		"archetypes":      a.refNames(a.application.Archetypes),
		"businessService": a.refName(a.application.BusinessService),
		"repository":      a.repoMap(a.application.Repository),
		"binary":          a.application.Binary,
	}
	values = api.Map{
		"application": application,
		"manifest":    manifest.Content,
		"tags":        tags,
	}
	return
}

// fetchRepository gets source repository.
func (a *Generate) fetchRepository() (sourceDir string, err error) {
	if a.application.Repository == nil {
		err = Wrap(
			&RepositoryNotDefined{
				Role: "Source",
			})
		return
	}
	var options []any
	idapi := addon.Application.Identity(a.application.ID)
	identity, found, err := idapi.Find("source")
	if err != nil {
		return
	}
	if found {
		options = append(options, identity)
	}
	sourceDir = path.Join(
		SourceDir,
		strings.Split(
			path.Base(
				a.application.Repository.URL),
			".")[0])
	var rp repository.SCM
	rp, err = repository.New(
		sourceDir,
		a.application.Repository,
		options...)
	if err != nil {
		return
	}
	err = rp.Fetch()
	if err != nil {
		return
	}
	sourceDir = path.Join(
		sourceDir,
		a.application.Repository.Path)
	return
}

// fetchTemplates clones the repository associated with the generator.
func (a *Generate) fetchTemplates(gen *api.Generator) (templateDir string, err error) {
	genId := strconv.Itoa(int(gen.ID))
	templateDir = path.Join(
		TemplateDir,
		genId)
	err = os.MkdirAll(templateDir, 0755)
	if err != nil {
		err = Wrap(err)
		return
	}
	template, err := repository.New(
		templateDir,
		gen.Repository,
		gen.Identity)
	if err != nil {
		return
	}
	err = template.Fetch()
	if err != nil {
		return
	}
	templateDir = path.Join(
		templateDir,
		gen.Repository.Path)
	return
}

// profiles returns requested profiles.
func (a *Generate) profiles(requested Profiles) (matched []*api.TargetProfile, err error) {
	for _, ref := range a.application.Archetypes {
		var arch *api.Archetype
		arch, err = addon.Archetype.Get(ref.ID)
		if err != nil {
			return
		}
		for _, p := range arch.Profiles {
			if requested.match(&p) {
				matched = append(matched, &p)
			}
		}
	}
	return
}

// generators returns requested generators.
func (a *Generate) generators(requested Profiles) (list []*api.Generator, err error) {
	profiles, err := a.profiles(requested)
	if err != nil {
		return
	}
	for _, p := range profiles {
		var gen *api.Generator
		for _, ref := range p.Generators {
			gen, err = addon.Generator.Get(ref.ID)
			if err == nil {
				list = append(list, gen)
			} else {
				return
			}
		}
	}
	return
}

// inject nodes into the manifest.
func (a *Generate) inject(manifest, d api.Map) {
	if d == nil {
		return
	}
	for k, value := range d {
		part := strings.Split(k, ".")
		leaf := len(part) - 1
		node := Map(manifest)
		for i := range part {
			p := part[i]
			if i == leaf {
				node[p] = value
				break
			}
			v, found := node[p]
			nested, cast := v.(Map)
			if !found || !cast {
				nested = make(Map)
				node[p] = nested
			}
			node = nested
		}
	}
}

// tags returns an array of tags.
// format: category=tag.
func (a *Generate) tags() (tags []string, err error) {
	catList, err := addon.TagCategory.List()
	if err != nil {
		return
	}
	catMap := make(map[uint]string)
	for _, cat := range catList {
		catMap[cat.ID] = cat.Name
	}
	for _, ref := range a.application.Tags {
		var tag *api.Tag
		tag, err = addon.Tag.Get(ref.ID)
		if err != nil {
			return
		}
		tags = append(
			tags,
			strings.Join(
				[]string{
					catMap[tag.Category.ID],
					tag.Name},
				"="))
	}
	return
}

// manifest returns the application manifest.
// Fallback: A file named: manifest.yaml in the source repository.
func (a *Generate) manifest() (manifest *api.Manifest, err error) {
	mapi := addon.Application.Manifest(a.application.ID)
	manifest, err = mapi.Get()
	if err != nil {
		if !errors.Is(err, &binding.NotFound{}) {
			return
		}
	} else {
		addon.Activity(
			"[Gen] Using manifest id=%d",
			manifest.ID)
		return
	}
	if a.application.Repository == nil {
		err = &ManifestNotFound{}
		return
	}
	sourceDir, err := a.fetchRepository()
	if err != nil {
		return
	}
	file := path.Join(sourceDir, "manifest.yaml")
	f, err := os.Open(file)
	if err != nil {
		if os.IsNotExist(err) {
			err = &ManifestNotFound{}
		} else {
			err = Wrap(err)
		}
		return
	}
	defer func() {
		_ = f.Close()
	}()
	manifest = &api.Manifest{}
	decoder := yaml.NewDecoder(f)
	err = decoder.Decode(&manifest.Content)
	if err == nil {
		addon.Activity(
			"[Gen] Using manifest at: ",
			file)
	}
	return
}

// refName returns the referenced name.
func (a *Generate) refName(ref *api.Ref) (n string) {
	if ref != nil {
		n = ref.Name
	}
	return
}

// refNames returns the referenced names.
func (a *Generate) refNames(refs []api.Ref) (names []string) {
	for _, ref := range refs {
		names = append(names, ref.Name)
	}
	return
}

// repoMap returns a map of a repository.
func (a *Generate) repoMap(r *api.Repository) (m api.Map) {
	m = api.Map{
		"kind":   "",
		"url":    "",
		"branch": "",
		"tag":    "",
		"path":   "",
	}
	if r != nil {
		return
	}
	b, _ := yaml.Marshal(r)
	_ = yaml.Unmarshal(b, &m)
	return
}

// Profiles selected profiles.
type Profiles []api.Ref

// match returns true when the profile ID matched.
func (f Profiles) match(p *api.TargetProfile) (matched bool) {
	if len(f) == 0 {
		matched = true
		return
	}
	for _, ref := range f {
		matched = ref.ID == p.ID
		if !matched {
			break
		}
	}
	return
}
